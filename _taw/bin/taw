#!/bin/bash

# TAW - Tmux + Agent + Worktree
# Initializes .taw directory and starts tmux session
# Works with or without git repository

set -e

# Parse arguments first (before sourcing _common.sh)
TAW_DEBUG=0
COMMAND=""
while [[ $# -gt 0 ]]; do
    case "$1" in
        -d|--debug)
            TAW_DEBUG=1
            shift
            ;;
        clean)
            COMMAND="clean"
            shift
            ;;
        *)
            echo "Unknown option: $1"
            echo "Usage: taw [-d|--debug] [clean]"
            exit 1
            ;;
    esac
done

# Resolve symlinks (needed to find TAW_HOME before sourcing _common.sh)
_resolve_path() {
    local path="$1"
    while [ -L "$path" ]; do
        local dir="$(cd "$(dirname "$path")" && pwd)"
        path="$(readlink "$path")"
        [[ "$path" != /* ]] && path="$dir/$path"
    done
    echo "$(cd "$(dirname "$path")" && pwd)/$(basename "$path")"
}

# Get the installation directory (where taw was installed from)
SCRIPT_PATH="$(_resolve_path "$0")"
TAW_HOME="$(cd "$(dirname "$SCRIPT_PATH")/../.." && pwd)"

# Source common utilities (provides debug, log, warn, tm, etc.)
source "$TAW_HOME/_taw/bin/_common.sh"

PROJECT_DIR="$(pwd)"
TAW_DIR="$PROJECT_DIR/.taw"
PROJECT_NAME="$(basename "$PROJECT_DIR")"

LOG_DIR="$TAW_DIR/.metadata/log"
LOG_FILE="$LOG_DIR/start.log"
AGENTS_DIR="$TAW_DIR/agents"
SESSION_NAME="$PROJECT_NAME"

# Note: log(), debug(), warn() are now provided by _common.sh
# Override tm() to use SESSION_NAME automatically (simpler than _common.sh version)
tm() {
    tmux -L "taw-$SESSION_NAME" "$@"
}

# Detect if current directory is a git repository root
# Sets IS_GIT_REPO=true/false
detect_git_repo() {
    IS_GIT_REPO=false

    local git_root
    git_root=$(git rev-parse --show-toplevel 2>/dev/null) || {
        echo "Not a git repository. Running in non-git mode."
        return 0
    }

    local current_real
    local git_root_real
    current_real=$(cd "$PROJECT_DIR" && pwd -P)
    git_root_real=$(cd "$git_root" && pwd -P)

    if [ "$current_real" != "$git_root_real" ]; then
        echo "Warning: Not at git repository root (root is: $git_root)"
        echo "Running in non-git mode."
        return 0
    fi

    IS_GIT_REPO=true
}

# Initialize .taw directory structure
init_taw_dir() {
    local is_new=false

    if [ ! -d "$TAW_DIR" ]; then
        is_new=true
        echo "Initializing .taw directory..."

        mkdir -p "$TAW_DIR"
        mkdir -p "$TAW_DIR/agents"
        mkdir -p "$TAW_DIR/.metadata/log"
    fi

    # Always update symlinks (fixes broken links after taw repo moved)
    rm -rf "$TAW_DIR/.claude" 2>/dev/null
    ln -s "$TAW_HOME/_taw/claude" "$TAW_DIR/.claude"

    rm -f "$TAW_DIR/new-task" 2>/dev/null
    ln -s "$TAW_HOME/_taw/bin/new-task" "$TAW_DIR/new-task"

    rm -f "$TAW_DIR/cleanup" 2>/dev/null
    ln -s "$TAW_HOME/_taw/bin/cleanup" "$TAW_DIR/cleanup"

    # Link appropriate global PROMPT based on git mode
    rm -f "$TAW_DIR/.global-prompt" 2>/dev/null
    if [ "$IS_GIT_REPO" = true ]; then
        ln -s "$TAW_HOME/_taw/PROMPT.md" "$TAW_DIR/.global-prompt"
        touch "$TAW_DIR/.is-git-repo"
    else
        ln -s "$TAW_HOME/_taw/PROMPT-nogit.md" "$TAW_DIR/.global-prompt"
        rm -f "$TAW_DIR/.is-git-repo" 2>/dev/null
    fi

    # Create project PROMPT.md if not exists
    if [ ! -f "$TAW_DIR/PROMPT.md" ]; then
        cat > "$TAW_DIR/PROMPT.md" << 'EOF'
# Project Prompt

Add project-specific instructions here.
EOF
    fi

    if [ "$is_new" = true ]; then
        echo "Initialized .taw directory."
    fi
}

# Add .taw to .gitignore if not already there
update_gitignore() {
    local gitignore="$PROJECT_DIR/.gitignore"

    # Check for any pattern that would ignore .taw
    # Patterns: .taw, .taw/, **/.taw, **/.taw/, /.taw, /.taw/
    is_taw_ignored() {
        [ -f "$gitignore" ] && grep -qE '^(\*\*/)?\.taw/?$|^/\.taw/?$' "$gitignore"
    }

    if ! is_taw_ignored; then
        if [ -f "$gitignore" ]; then
            echo ".taw" >> "$gitignore"
            echo "Added .taw to .gitignore"
        else
            echo ".taw" > "$gitignore"
            echo "Created .gitignore with .taw"
        fi
    fi
}

check_dependencies() {
    if ! command -v tmux &> /dev/null; then
        echo "tmux is not installed. Install: brew install tmux"
        exit 1
    fi
}

is_session_running() {
    tmux -L "taw-$SESSION_NAME" has-session -t "$SESSION_NAME" 2>/dev/null
}

# Full cleanup: remove everything taw-related for this project
clean_all() {
    echo "=== TAW Clean ==="
    echo "Project: $PROJECT_NAME"
    echo "Directory: $PROJECT_DIR"
    echo ""

    # Check what will be cleaned
    local has_session=false
    local has_taw_dir=false
    local worktrees=()
    local branches=()

    # Check tmux session
    if tmux -L "taw-$SESSION_NAME" has-session -t "$SESSION_NAME" 2>/dev/null; then
        has_session=true
        echo "• Tmux session: taw-$SESSION_NAME"
    fi

    # Check .taw directory
    if [ -d "$TAW_DIR" ]; then
        has_taw_dir=true
        echo "• Directory: $TAW_DIR"

        # Find worktrees and branches from agents
        if [ -d "$AGENTS_DIR" ]; then
            for agent_dir in "$AGENTS_DIR"/*/; do
                [ -d "$agent_dir" ] || continue
                local task_name=$(basename "$agent_dir")

                # Check if worktree exists
                if [ -d "$agent_dir/worktree" ]; then
                    worktrees+=("$agent_dir/worktree")
                    echo "• Worktree: $agent_dir/worktree"
                fi

                # Check if branch exists
                if git -C "$PROJECT_DIR" rev-parse --verify "$task_name" &>/dev/null; then
                    branches+=("$task_name")
                    echo "• Branch: $task_name"
                fi
            done
        fi
    fi

    # Nothing to clean
    if ! $has_session && ! $has_taw_dir && [ ${#worktrees[@]} -eq 0 ] && [ ${#branches[@]} -eq 0 ]; then
        echo "Nothing to clean."
        exit 0
    fi

    echo ""
    read -p "Delete all? [y/N] " -n 1 -r
    echo ""

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Cancelled."
        exit 0
    fi

    echo ""

    # 1. Kill tmux session first
    if $has_session; then
        echo "Killing tmux session..."
        tmux -L "taw-$SESSION_NAME" kill-server 2>/dev/null || true
    fi

    # 2. Remove worktrees
    for wt in "${worktrees[@]}"; do
        echo "Removing worktree: $wt"
        git -C "$PROJECT_DIR" worktree remove "$wt" --force 2>/dev/null || true
    done

    # 3. Prune worktree references
    git -C "$PROJECT_DIR" worktree prune 2>/dev/null || true

    # 4. Delete branches
    for branch in "${branches[@]}"; do
        echo "Deleting branch: $branch"
        git -C "$PROJECT_DIR" branch -D "$branch" 2>/dev/null || true
    done

    # 5. Remove .taw directory
    if $has_taw_dir; then
        echo "Removing $TAW_DIR..."
        rm -rf "$TAW_DIR"
    fi

    # 6. Remove .claude symlink in PROJECT_DIR if it points to .taw/.claude
    if [ -L "$PROJECT_DIR/.claude" ]; then
        local link_target=$(readlink "$PROJECT_DIR/.claude")
        if [[ "$link_target" == *".taw/.claude"* ]] || [[ "$link_target" == "$TAW_DIR/.claude" ]]; then
            echo "Removing $PROJECT_DIR/.claude symlink..."
            rm -f "$PROJECT_DIR/.claude"
        fi
    fi

    echo ""
    echo "Done."
}

# Reopen incomplete tasks (tasks where window was closed but not done)
reopen_incomplete_tasks() {
    local incomplete_tasks
    incomplete_tasks=$(find_incomplete_tasks "$AGENTS_DIR" "$SESSION_NAME")

    [ -z "$incomplete_tasks" ] && return 0

    echo "$incomplete_tasks" | while IFS= read -r agent_dir; do
        [ -z "$agent_dir" ] && continue
        local task_name=$(basename "$agent_dir")
        log "Reopening incomplete task: $task_name"
        debug "Reopening: $agent_dir"

        # Use handle-task with --reopen --no-input flags
        nohup "$TAW_HOME/_taw/bin/handle-task" --reopen --no-input "$agent_dir" >> "$LOG_DIR/handle-task.log" 2>&1 &
    done
}

start_session() {
    check_dependencies

    # Create directories
    mkdir -p "$LOG_DIR"
    mkdir -p "$AGENTS_DIR"

    log "=== Session start ==="
    log "Project: $PROJECT_NAME"
    log "Directory: $PROJECT_DIR"
    log "TAW Directory: $TAW_DIR"

    # Clean up tab markers from previous session
    find "$AGENTS_DIR" -name ".tab-created" -delete 2>/dev/null

    echo "Starting session '$SESSION_NAME'..."

    # Start tmux session with temporary window
    cd "$PROJECT_DIR"
    tm new-session -d -s "$SESSION_NAME" -n "_" -c "$PROJECT_DIR"
    log "Tmux session created: $SESSION_NAME"

    # Configure tmux session
    tm set -t "$SESSION_NAME" mouse on

    # Unbind all default keys and set minimal bindings
    tm unbind-key -a
    tm bind -n C-q detach
    tm bind -n C-n run-shell "tmux new-window -t '$SESSION_NAME' -n '_' -c '$PROJECT_DIR' '$TAW_HOME/_taw/bin/new-task'"
    # Pane: Alt + arrows to move, Alt + hjkl to split, Alt + x to close
    tm bind -n M-Left select-pane -L
    tm bind -n M-Right select-pane -R
    tm bind -n M-Up select-pane -U
    tm bind -n M-Down select-pane -D
    tm bind -n M-h split-window -hb -c "#{pane_current_path}"
    tm bind -n M-j split-window -v -c "#{pane_current_path}"
    tm bind -n M-k split-window -vb -c "#{pane_current_path}"
    tm bind -n M-l split-window -h -c "#{pane_current_path}"
    tm bind -n M-x kill-pane
    # Window: Ctrl+Alt + arrows (using Shift+Alt as fallback for compatibility)
    tm bind -n S-M-Left previous-window
    tm bind -n S-M-Right next-window
    # End task: Ctrl+X - directly run cleanup script (no agent needed)
    tm bind -n C-x run-shell "$TAW_HOME/_taw/bin/end-task '$SESSION_NAME' '#{window_id}'"
    # Help: Alt+/ - show help in temporary window
    tm bind -n M-/ new-window -n "HELP" "less '$TAW_HOME/_taw/HELP.md'"
    # Quick task: Ctrl+Alt+A - add task to queue via popup
    tm bind -n C-M-a run-shell "$TAW_HOME/_taw/bin/quick-task '$SESSION_NAME'"
    # Popup shell: Ctrl+A - toggle popup shell in worktree directory
    tm bind -n C-a run-shell "$TAW_HOME/_taw/bin/popup-shell '$SESSION_NAME'"
    log "Tmux configured"

    # Status line: 2 lines - windows on top, hints on bottom
    tm set -t "$SESSION_NAME" status 2
    tm set -t "$SESSION_NAME" status-format[0] "#[align=left]#{W:#[fg=white bg=default] #W #[default],#[fg=white bg=blue bold] #W #[default]}"
    tm set -t "$SESSION_NAME" status-format[1] "#[align=left fg=brightblack] ^a:popup  ^n:new  ^x:end  ^⌥a:queue  ⌥←→↑↓:pane  ⌥hjkl:split  ⇧⌥←→:window  ^q:quit  ⌥/:help"

    # Run new-task in the initial window, then exit to close _ window
    debug "Running new-task in initial window..."
    tm send-keys -t "$SESSION_NAME:_" "$TAW_HOME/_taw/bin/new-task; exit" Enter

    # Reopen any incomplete tasks from previous sessions
    debug "Checking for incomplete tasks..."
    reopen_incomplete_tasks

    # Attach to session
    log "Attaching to session"
    printf '\e]1;%s\a' "taw: $SESSION_NAME"
    tm attach -t "$SESSION_NAME"
}

# === Main ===

# Handle clean command (can run inside tmux)
if [ "$COMMAND" = "clean" ]; then
    clean_all
    exit 0
fi

# Check if already inside tmux session
if [ -n "$TMUX" ]; then
    echo "Already inside tmux session. Ignoring."
    exit 0
fi

# Detect git repo and initialize
debug "Detecting git repo..."
detect_git_repo
debug "IS_GIT_REPO=$IS_GIT_REPO"
debug "Initializing taw directory..."
init_taw_dir
debug "TAW_DIR=$TAW_DIR"
if [ "$IS_GIT_REPO" = true ]; then
    update_gitignore
fi

# Ensure log directory exists for reattach logging
mkdir -p "$LOG_DIR"

# Export TAW_HOME and TAW_DEBUG for child scripts
export TAW_HOME TAW_DEBUG

# If session exists, attach to it; otherwise start new
if is_session_running; then
    log "Reattaching to existing session: $SESSION_NAME"
    echo "Attaching to existing session '$SESSION_NAME'..."

    # Reopen any incomplete tasks
    debug "Checking for incomplete tasks..."
    reopen_incomplete_tasks

    printf '\e]1;%s\a' "taw: $SESSION_NAME"
    tm attach -t "$SESSION_NAME"
else
    start_session
fi
