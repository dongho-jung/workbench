#!/bin/bash

# TAW - Tmux + Agent + Worktree
# Initializes .taw directory in current git project and starts tmux session

set -e

# Resolve symlinks (macOS compatible)
resolve_path() {
    local path="$1"
    while [ -L "$path" ]; do
        local dir="$(cd "$(dirname "$path")" && pwd)"
        path="$(readlink "$path")"
        [[ "$path" != /* ]] && path="$dir/$path"
    done
    echo "$(cd "$(dirname "$path")" && pwd)/$(basename "$path")"
}

# Get the installation directory (where taw was installed from)
SCRIPT_PATH="$(resolve_path "$0")"
TAW_HOME="$(cd "$(dirname "$SCRIPT_PATH")/../.." && pwd)"

PROJECT_DIR="$(pwd)"
TAW_DIR="$PROJECT_DIR/.taw"
PROJECT_NAME="$(basename "$PROJECT_DIR")"

WATCHER_DIR="$TAW_DIR/.metadata/watcher"
LOG_DIR="$TAW_DIR/.metadata/log"
LOG_FILE="$LOG_DIR/start.log"
AGENTS_DIR="$TAW_DIR/agents"
SESSION_NAME="$PROJECT_NAME"

GLOBAL_PROMPT="$TAW_HOME/_taw/PROMPT.md"
PROJECT_PROMPT="$TAW_DIR/PROMPT.md"

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$LOG_FILE"
}

# Check if current directory is a git repository root
check_git_root() {
    local git_root
    git_root=$(git rev-parse --show-toplevel 2>/dev/null) || {
        echo "Error: Not a git repository."
        echo "Run 'taw' from a git project root directory."
        exit 1
    }

    local current_real
    local git_root_real
    current_real=$(cd "$PROJECT_DIR" && pwd -P)
    git_root_real=$(cd "$git_root" && pwd -P)

    if [ "$current_real" != "$git_root_real" ]; then
        echo "Error: Not at git repository root."
        echo "Git root is: $git_root"
        echo "Please cd to the git root and run 'taw' again."
        exit 1
    fi
}

# Initialize .taw directory structure
init_taw_dir() {
    local is_new=false

    if [ ! -d "$TAW_DIR" ]; then
        is_new=true
        echo "Initializing .taw directory..."

        mkdir -p "$TAW_DIR"
        mkdir -p "$TAW_DIR/agents"
        mkdir -p "$TAW_DIR/.metadata/watcher"
        mkdir -p "$TAW_DIR/.metadata/log"
        touch "$TAW_DIR/.metadata/watcher/watcher.log"
    fi

    # Always update symlinks (fixes broken links after taw repo moved)
    rm -rf "$TAW_DIR/.claude" 2>/dev/null
    ln -s "$TAW_HOME/_taw/claude" "$TAW_DIR/.claude"

    rm -f "$TAW_DIR/new-task" 2>/dev/null
    ln -s "$TAW_HOME/_taw/bin/new-task" "$TAW_DIR/new-task"

    rm -f "$TAW_DIR/cleanup" 2>/dev/null
    ln -s "$TAW_HOME/_taw/bin/cleanup" "$TAW_DIR/cleanup"

    # Create project PROMPT.md if not exists
    if [ ! -f "$TAW_DIR/PROMPT.md" ]; then
        cat > "$TAW_DIR/PROMPT.md" << 'EOF'
# Project Prompt

Add project-specific instructions here.
EOF
    fi

    if [ "$is_new" = true ]; then
        echo "Initialized .taw directory."
    fi
}

# Add .taw to .gitignore if not already there
update_gitignore() {
    local gitignore="$PROJECT_DIR/.gitignore"

    # Check for any pattern that would ignore .taw
    # Patterns: .taw, .taw/, **/.taw, **/.taw/, /.taw, /.taw/
    is_taw_ignored() {
        [ -f "$gitignore" ] && grep -qE '^(\*\*/)?\.taw/?$|^/\.taw/?$' "$gitignore"
    }

    if ! is_taw_ignored; then
        if [ -f "$gitignore" ]; then
            echo ".taw" >> "$gitignore"
            echo "Added .taw to .gitignore"
        else
            echo ".taw" > "$gitignore"
            echo "Created .gitignore with .taw"
        fi
    fi
}

check_dependencies() {
    if ! command -v tmux &> /dev/null; then
        echo "tmux is not installed. Install: brew install tmux"
        exit 1
    fi
    if ! command -v fswatch &> /dev/null; then
        echo "fswatch is not installed. Install: brew install fswatch"
        exit 1
    fi
}

is_session_running() {
    tmux -L "taw-$SESSION_NAME" has-session -t "$SESSION_NAME" 2>/dev/null
}

tm() {
    tmux -L "taw-$SESSION_NAME" "$@"
}

cleanup() {
    log "Cleanup started"
    echo "Cleaning up..."
    pkill -f "fswatch.*$TAW_DIR/agents" 2>/dev/null
    rm -f "$WATCHER_DIR/watcher.pid"
    log "Cleanup completed"
}

# Truncate tab name to 32 chars with ... in middle if needed
truncate_tab_name() {
    local name="$1"
    local max_len=32
    local len=${#name}

    if [ $len -le $max_len ]; then
        echo "$name"
    else
        local keep=$(( (max_len - 3) / 2 ))
        local left="${name:0:$keep}"
        local right="${name: -$keep}"
        echo "${left}...${right}"
    fi
}

handle_task() {
    local task_file="$1"
    local agent_dir=$(dirname "$task_file")
    local task_name=$(basename "$agent_dir")

    # Only process files named "task"
    if [[ "$(basename "$task_file")" != "task" ]]; then
        return
    fi

    local tab_marker="$agent_dir/.tab-created"

    # Skip if already processed
    if [ -f "$tab_marker" ]; then
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Task already processed: $task_name" >> "$WATCHER_DIR/watcher.log"
        return
    fi

    echo "[$(date '+%Y-%m-%d %H:%M:%S')] New task detected: $task_name" >> "$WATCHER_DIR/watcher.log"

    # Create origin and attach symlinks if they don't exist
    if [ ! -L "$agent_dir/origin" ]; then
        ln -s ../../.. "$agent_dir/origin" 2>/dev/null || true
    fi
    if [ ! -L "$agent_dir/attach" ]; then
        ln -s "$TAW_HOME/_taw/bin/attach" "$agent_dir/attach" 2>/dev/null || true
    fi

    # Create worktree for this task (enforced - agent cannot skip this)
    local worktree_dir="$agent_dir/worktree"
    if [ ! -d "$worktree_dir" ]; then
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Creating worktree: $worktree_dir" >> "$WATCHER_DIR/watcher.log"
        git -C "$PROJECT_DIR" worktree prune 2>/dev/null || true
        if ! git -C "$PROJECT_DIR" worktree add "$worktree_dir" -b "$task_name" 2>> "$WATCHER_DIR/watcher.log"; then
            # Branch might already exist, try without -b
            if ! git -C "$PROJECT_DIR" worktree add "$worktree_dir" "$task_name" 2>> "$WATCHER_DIR/watcher.log"; then
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] Failed to create worktree for $task_name" >> "$WATCHER_DIR/watcher.log"
                return 1
            fi
        fi
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Worktree created: $worktree_dir" >> "$WATCHER_DIR/watcher.log"
    fi

    # Build system prompt from global and project PROMPT files
    local system_prompt=""
    if [ -f "$GLOBAL_PROMPT" ]; then
        system_prompt=$(cat "$GLOBAL_PROMPT")
    fi
    if [ -f "$PROJECT_PROMPT" ]; then
        if [ -n "$system_prompt" ]; then
            system_prompt="$system_prompt"$'\n\n---\n\n'
        fi
        system_prompt="$system_prompt$(cat "$PROJECT_PROMPT")"
    fi

    # Read task content
    local task_content=""
    if [ -f "$task_file" ]; then
        task_content=$(cat "$task_file")
    fi

    # Build the user prompt with task context
    local user_prompt="# Task: $task_name

**Worktree**: $worktree_dir
**Project**: $PROJECT_DIR

$task_content"

    # Save prompts to files (hidden)
    echo "$system_prompt" > "$agent_dir/.system-prompt"
    echo "$user_prompt" > "$agent_dir/.user-prompt"

    # Create new window with truncated name and working emoji
    # Working directory is the WORKTREE, not project root
    local display_name=$(truncate_tab_name "$task_name")
    local window_name="ü§ñ${display_name}"

    # Get window ID for reliable targeting (emoji in name can cause issues)
    local window_id
    window_id=$(tm new-window -t "$SESSION_NAME" -n "$window_name" -c "$worktree_dir" -P -F "#{window_id}")
    touch "$tab_marker"

    sleep 0.5

    # Split horizontally (creates right pane for user) - also in worktree
    tm split-window -t "$window_id" -h -c "$worktree_dir"

    # Select left pane (agent pane)
    tm select-pane -t "${window_id}.0"

    # Send shell command (normal Enter)
    send_shell_cmd() {
        tm send-keys -t "${window_id}.0" -l "$1"
        tm send-keys -t "${window_id}.0" Enter
    }

    # Send input to claude code (Escape to exit multiline, then raw ASCII 13 to submit)
    send_to_claude() {
        tm send-keys -t "${window_id}.0" -l "$1"
        sleep 0.1
        tm send-keys -t "${window_id}.0" Escape
        sleep 0.1
        tm send-keys -t "${window_id}.0" -H 0d  # ASCII 13 (Carriage Return)
    }

    # Helper to get pane content
    get_pane_content() {
        tm capture-pane -t "${window_id}.0" -p 2>/dev/null || echo ""
    }

    # Wait for claude to be ready (poll until we see expected output)
    wait_for_claude_ready() {
        local max_attempts=60  # 30 seconds max
        local attempt=0
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Waiting for claude to be ready..." >> "$WATCHER_DIR/watcher.log"
        while [ $attempt -lt $max_attempts ]; do
            local content=$(get_pane_content)
            # Claude is ready when we see trust prompt or the input prompt (‚ï≠‚îÄ)
            if echo "$content" | grep -qE "Trust|trust|‚ï≠‚îÄ"; then
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] Claude ready after $attempt attempts" >> "$WATCHER_DIR/watcher.log"
                return 0
            fi
            sleep 0.5
            attempt=$((attempt + 1))
        done
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Timeout waiting for claude" >> "$WATCHER_DIR/watcher.log"
        return 1
    }

    # Start claude interactively with system prompt (export env vars for slash commands)
    send_shell_cmd "export TASK_NAME='$task_name' TAW_DIR='$TAW_DIR' PROJECT_DIR='$PROJECT_DIR' WORKTREE_DIR='$worktree_dir' WINDOW_ID='$window_id' && claude --dangerously-skip-permissions --system-prompt \"\$(cat $agent_dir/.system-prompt)\""

    # Wait for claude to be ready
    if ! wait_for_claude_ready; then
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Failed to start claude for $task_name" >> "$WATCHER_DIR/watcher.log"
        return 1
    fi

    # Check if confirmation is needed
    local screen_content
    screen_content=$(get_pane_content)
    if echo "$screen_content" | grep -qiE "trust|Trust this project|y/n|\[y\]|Are you sure"; then
        send_shell_cmd "y"
        # Wait for claude to be ready again after trust confirmation
        wait_for_claude_ready
    fi

    # Send the task instruction to claude
    send_to_claude "Read and execute the task from $agent_dir/.user-prompt"

    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Created window: $window_name, sent task to claude" >> "$WATCHER_DIR/watcher.log"

    # Kill the temporary "_" window if it exists and this is the first task
    tm kill-window -t "$SESSION_NAME:_" 2>/dev/null || true
}

start_watcher() {
    # Wait for session to start
    for i in {1..30}; do
        if is_session_running; then
            break
        fi
        sleep 0.5
    done

    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Watcher started" >> "$WATCHER_DIR/watcher.log"

    # Watch agents directory for new task files
    fswatch -x --event Created --event Renamed -r "$TAW_DIR/agents" 2>/dev/null | while read -r line; do
        changed_file=$(echo "$line" | awk '{print $1}')

        # Skip directories
        if [ -d "$changed_file" ]; then
            continue
        fi

        # Only process files named "task"
        if [[ "$(basename "$changed_file")" != "task" ]]; then
            continue
        fi

        if ! is_session_running; then
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Session not running, stopping watcher" >> "$WATCHER_DIR/watcher.log"
            break
        fi

        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Task file detected: $changed_file" >> "$WATCHER_DIR/watcher.log"

        # Use mkdir-based lock to serialize task handling (prevent race conditions)
        # mkdir is atomic, so only one process can succeed
        lock_dir="$WATCHER_DIR/.task.lock"
        while ! mkdir "$lock_dir" 2>/dev/null; do
            sleep 0.5
        done
        # Ensure lock is released even if handle_task fails
        handle_task "$changed_file" || true
        rmdir "$lock_dir" 2>/dev/null || true
    done
}

start_session() {
    check_dependencies

    # Create directories
    mkdir -p "$WATCHER_DIR"
    mkdir -p "$LOG_DIR"
    mkdir -p "$AGENTS_DIR"
    touch "$WATCHER_DIR/watcher.log"

    log "=== Session start ==="
    log "Project: $PROJECT_NAME"
    log "Directory: $PROJECT_DIR"
    log "TAW Directory: $TAW_DIR"

    # Clean up tab markers from previous session
    find "$AGENTS_DIR" -name ".tab-created" -delete 2>/dev/null

    echo "Starting session '$SESSION_NAME'..."

    # Start watcher in background
    start_watcher &
    local watcher_pid=$!
    echo "$watcher_pid" > "$WATCHER_DIR/watcher.pid"
    log "Watcher started (PID: $watcher_pid)"

    # Cleanup on exit
    trap cleanup EXIT

    # Start tmux session with temporary window
    cd "$PROJECT_DIR"
    tm new-session -d -s "$SESSION_NAME" -n "_" -c "$PROJECT_DIR"
    log "Tmux session created: $SESSION_NAME"

    # Configure tmux session
    tm set -t "$SESSION_NAME" mouse on

    # Unbind all default keys and set minimal bindings
    tm unbind-key -a
    tm bind -n C-q detach
    tm bind -n C-n run-shell "tmux new-window -t '$SESSION_NAME' -n '_' -c '$PROJECT_DIR' '$TAW_HOME/_taw/bin/new-task'"
    # Pane: Alt + arrows to move, Alt + hjkl to split, Alt + x to close
    tm bind -n M-Left select-pane -L
    tm bind -n M-Right select-pane -R
    tm bind -n M-Up select-pane -U
    tm bind -n M-Down select-pane -D
    tm bind -n M-h split-window -hb -c "#{pane_current_path}"
    tm bind -n M-j split-window -v -c "#{pane_current_path}"
    tm bind -n M-k split-window -vb -c "#{pane_current_path}"
    tm bind -n M-l split-window -h -c "#{pane_current_path}"
    tm bind -n M-x kill-pane
    # Window: Ctrl+Alt + arrows (using Shift+Alt as fallback for compatibility)
    tm bind -n S-M-Left previous-window
    tm bind -n S-M-Right next-window
    # End task: Ctrl+E - send /done to agent pane (pane 0)
    # Sequence: Escape (exit multiline) -> Ctrl+C (cancel current) -> /done text -> Escape -> Enter
    tm bind -n C-e run-shell "tmux send-keys -t .0 Escape; sleep 0.3; tmux send-keys -t .0 C-c; sleep 0.5; tmux send-keys -t .0 -l '/done'; sleep 0.2; tmux send-keys -t .0 Escape; sleep 0.2; tmux send-keys -t .0 -H 0d"
    # Help: Alt+/ - show help in temporary window
    tm bind -n M-/ new-window -n "HELP" "less '$TAW_HOME/_taw/HELP.md'"
    log "Tmux configured"

    # Status line: 2 lines - windows on top, hints on bottom
    tm set -t "$SESSION_NAME" status 2
    tm set -t "$SESSION_NAME" status-format[0] "#[align=left]#{W:#[fg=white bg=default] #W #[default],#[fg=white bg=blue bold] #W #[default]}"
    tm set -t "$SESSION_NAME" status-format[1] "#[align=left fg=brightblack] ^n:new-task  ^e:end-task  ‚å•‚Üê‚Üí‚Üë‚Üì:move-pane  ‚å•hjkl:split-pane  ‚å•x:close-pane  ‚áß‚å•‚Üê‚Üí:move-window  ^q:quit  ‚å•/:help"

    # Run new-task in the initial window (will be killed after first task is created)
    tm send-keys -t "$SESSION_NAME:_" "$TAW_HOME/_taw/bin/new-task" Enter

    # Attach to session
    log "Attaching to session"
    tm attach -t "$SESSION_NAME"

    # This runs after tmux exits
    cleanup
}

# === Main ===

# Check if already inside tmux session
if [ -n "$TMUX" ]; then
    echo "Already inside tmux session. Ignoring."
    exit 0
fi

# Check git root and initialize
check_git_root
init_taw_dir
update_gitignore

# Ensure log directory exists for reattach logging
mkdir -p "$LOG_DIR"

# Export TAW_HOME for child scripts
export TAW_HOME

# If session exists, attach to it; otherwise start new
if is_session_running; then
    log "Reattaching to existing session: $SESSION_NAME"
    echo "Attaching to existing session '$SESSION_NAME'..."
    tm attach -t "$SESSION_NAME"
else
    start_session
fi
