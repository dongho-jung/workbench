#!/bin/bash

# TAW - Tmux + Agent + Worktree
# Initializes .taw directory and starts tmux session
# Works with or without git repository

set -e

# Parse arguments first (before sourcing _common.sh)
TAW_DEBUG=0
COMMAND=""
while [[ $# -gt 0 ]]; do
    case "$1" in
        -d|--debug)
            TAW_DEBUG=1
            shift
            ;;
        clean)
            COMMAND="clean"
            shift
            ;;
        setup)
            COMMAND="setup"
            shift
            ;;
        *)
            echo "Unknown option: $1"
            echo "Usage: taw [-d|--debug] [clean|setup]"
            exit 1
            ;;
    esac
done

# Resolve symlinks (needed to find TAW_HOME before sourcing _common.sh)
_resolve_path() {
    local path="$1"
    while [ -L "$path" ]; do
        local dir="$(cd "$(dirname "$path")" && pwd)"
        path="$(readlink "$path")"
        [[ "$path" != /* ]] && path="$dir/$path"
    done
    echo "$(cd "$(dirname "$path")" && pwd)/$(basename "$path")"
}

# Get the installation directory (where taw was installed from)
SCRIPT_PATH="$(_resolve_path "$0")"
TAW_HOME="$(cd "$(dirname "$SCRIPT_PATH")/../.." && pwd)"

# Source common utilities (provides debug, log, warn, tm, etc.)
source "$TAW_HOME/_taw/bin/_common.sh"

PROJECT_DIR="$(pwd)"
TAW_DIR="$PROJECT_DIR/.taw"
PROJECT_NAME="$(basename "$PROJECT_DIR")"

AGENTS_DIR="$TAW_DIR/agents"
SESSION_NAME="$PROJECT_NAME"

# Note: log(), debug(), warn() are now provided by _common.sh
# Override tm() to use SESSION_NAME automatically (simpler than _common.sh version)
tm() {
    tmux -L "taw-$SESSION_NAME" "$@"
}

# Detect if current directory is a git repository root
# Sets IS_GIT_REPO=true/false
detect_git_repo() {
    IS_GIT_REPO=false

    local git_root
    git_root=$(git rev-parse --show-toplevel 2>/dev/null) || {
        echo "Not a git repository. Running in non-git mode."
        return 0
    }

    local current_real
    local git_root_real
    current_real=$(cd "$PROJECT_DIR" && pwd -P)
    git_root_real=$(cd "$git_root" && pwd -P)

    if [ "$current_real" != "$git_root_real" ]; then
        echo "Warning: Not at git repository root (root is: $git_root)"
        echo "Running in non-git mode."
        return 0
    fi

    IS_GIT_REPO=true
}

# Run initial setup wizard (only for new directories)
run_setup() {
    debug "Running initial setup wizard..."
    if [ -t 0 ] && [ -t 1 ]; then
        # Interactive mode - run setup
        "$TAW_HOME/_taw/bin/setup" "$TAW_DIR" "$IS_GIT_REPO"
    else
        # Non-interactive mode - create default config
        debug "Non-interactive mode, creating default config"
        cat > "$TAW_DIR/config" << 'EOF'
# TAW Configuration (auto-generated with defaults)
# Run 'taw' again to reconfigure interactively

work_mode: worktree
on_complete: confirm
EOF
    fi
}

# Initialize .taw directory structure
init_taw_dir() {
    local is_new=false

    if [ ! -d "$TAW_DIR" ]; then
        is_new=true
        echo "Initializing .taw directory..."

        mkdir -p "$TAW_DIR"
        mkdir -p "$TAW_DIR/agents"
        mkdir -p "$TAW_DIR/.metadata/log"
    fi

    # Always update symlinks (fixes broken links after taw repo moved)
    rm -rf "$TAW_DIR/.claude" 2>/dev/null
    ln -s "$TAW_HOME/_taw/claude" "$TAW_DIR/.claude"

    rm -f "$TAW_DIR/new-task" 2>/dev/null
    ln -s "$TAW_HOME/_taw/bin/new-task" "$TAW_DIR/new-task"

    rm -f "$TAW_DIR/cleanup" 2>/dev/null
    ln -s "$TAW_HOME/_taw/bin/cleanup" "$TAW_DIR/cleanup"

    # Link appropriate global PROMPT based on git mode
    rm -f "$TAW_DIR/.global-prompt" 2>/dev/null
    if [ "$IS_GIT_REPO" = true ]; then
        ln -s "$TAW_HOME/_taw/PROMPT.md" "$TAW_DIR/.global-prompt"
        touch "$TAW_DIR/.is-git-repo"
    else
        ln -s "$TAW_HOME/_taw/PROMPT-nogit.md" "$TAW_DIR/.global-prompt"
        rm -f "$TAW_DIR/.is-git-repo" 2>/dev/null
    fi

    # Create project PROMPT.md if not exists
    if [ ! -f "$TAW_DIR/PROMPT.md" ]; then
        cat > "$TAW_DIR/PROMPT.md" << 'EOF'
# Project Prompt

Add project-specific instructions here.
EOF
    fi

    if [ "$is_new" = true ]; then
        echo "Initialized .taw directory."
        # Run setup wizard for new directories (if config doesn't exist)
        if [ ! -f "$TAW_DIR/config" ]; then
            run_setup
        fi
    fi
}

# Add .taw to .gitignore if not already there
update_gitignore() {
    local gitignore="$PROJECT_DIR/.gitignore"

    # Check for any pattern that would ignore .taw
    # Patterns: .taw, .taw/, **/.taw, **/.taw/, /.taw, /.taw/
    is_taw_ignored() {
        [ -f "$gitignore" ] && grep -qE '^(\*\*/)?\.taw/?$|^/\.taw/?$' "$gitignore"
    }

    if ! is_taw_ignored; then
        if [ -f "$gitignore" ]; then
            echo ".taw" >> "$gitignore"
            echo "Added .taw to .gitignore"
        else
            echo ".taw" > "$gitignore"
            echo "Created .gitignore with .taw"
        fi
    fi
}

check_dependencies() {
    if ! command -v tmux &> /dev/null; then
        echo "tmux is not installed. Install: brew install tmux"
        exit 1
    fi
}

is_session_running() {
    tmux -L "taw-$SESSION_NAME" has-session -t "$SESSION_NAME" 2>/dev/null
}

# Full cleanup: remove everything taw-related for this project
clean_all() {
    echo "=== TAW Clean ==="
    echo "Project: $PROJECT_NAME"
    echo "Directory: $PROJECT_DIR"
    echo ""

    # Check what will be cleaned
    local has_session=false
    local has_taw_dir=false
    local worktrees=()
    local branches=()

    # Check tmux session
    if tmux -L "taw-$SESSION_NAME" has-session -t "$SESSION_NAME" 2>/dev/null; then
        has_session=true
        echo "• Tmux session: taw-$SESSION_NAME"
    fi

    # Check .taw directory
    if [ -d "$TAW_DIR" ]; then
        has_taw_dir=true
        echo "• Directory: $TAW_DIR"

        # Find worktrees and branches from agents
        if [ -d "$AGENTS_DIR" ]; then
            for agent_dir in "$AGENTS_DIR"/*/; do
                [ -d "$agent_dir" ] || continue
                local task_name=$(basename "$agent_dir")

                # Check if worktree exists
                if [ -d "$agent_dir/worktree" ]; then
                    worktrees+=("$agent_dir/worktree")
                    echo "• Worktree: $agent_dir/worktree"
                fi

                # Check if branch exists
                if git -C "$PROJECT_DIR" rev-parse --verify "$task_name" &>/dev/null; then
                    branches+=("$task_name")
                    echo "• Branch: $task_name"
                fi
            done
        fi
    fi

    # Nothing to clean
    if ! $has_session && ! $has_taw_dir && [ ${#worktrees[@]} -eq 0 ] && [ ${#branches[@]} -eq 0 ]; then
        echo "Nothing to clean."
        exit 0
    fi

    echo ""
    read -p "Delete all? [y/N] " -n 1 -r
    echo ""

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Cancelled."
        exit 0
    fi

    echo ""

    # 1. Kill tmux session first
    if $has_session; then
        echo "Killing tmux session..."
        tmux -L "taw-$SESSION_NAME" kill-server 2>/dev/null || true
    fi

    # 2. Remove worktrees
    for wt in "${worktrees[@]}"; do
        echo "Removing worktree: $wt"
        git -C "$PROJECT_DIR" worktree remove "$wt" --force 2>/dev/null || true
    done

    # 3. Prune worktree references
    git -C "$PROJECT_DIR" worktree prune 2>/dev/null || true

    # 4. Delete branches
    for branch in "${branches[@]}"; do
        echo "Deleting branch: $branch"
        git -C "$PROJECT_DIR" branch -D "$branch" 2>/dev/null || true
    done

    # 5. Remove .taw directory
    if $has_taw_dir; then
        echo "Removing $TAW_DIR..."
        rm -rf "$TAW_DIR"
    fi

    # 6. Remove .claude symlink in PROJECT_DIR if it points to .taw/.claude
    if [ -L "$PROJECT_DIR/.claude" ]; then
        local link_target=$(readlink "$PROJECT_DIR/.claude")
        if [[ "$link_target" == *".taw/.claude"* ]] || [[ "$link_target" == "$TAW_DIR/.claude" ]]; then
            echo "Removing $PROJECT_DIR/.claude symlink..."
            rm -f "$PROJECT_DIR/.claude"
        fi
    fi

    echo ""
    echo "Done."
}

# Auto-cleanup merged tasks (tasks where branch has been merged externally)
auto_cleanup_merged_tasks() {
    # Only in git mode
    [ "$IS_GIT_REPO" = true ] || return 0

    local merged_tasks
    merged_tasks=$(find_merged_tasks "$AGENTS_DIR" "$PROJECT_DIR" "$SESSION_NAME")

    [ -z "$merged_tasks" ] && return 0

    echo "$merged_tasks" | while IFS= read -r agent_dir; do
        [ -z "$agent_dir" ] && continue
        local task_name=$(basename "$agent_dir")
        local tab_lock="$agent_dir/.tab-lock"
        local window_id_file="$tab_lock/window_id"

        log "Auto-cleaning merged task: $task_name"
        debug "Cleaning merged task: $agent_dir"

        # If window exists, close it first
        if [ -f "$window_id_file" ]; then
            local window_id=$(cat "$window_id_file")
            if tm list-windows -F "#{window_id}" 2>/dev/null | grep -q "^${window_id}$"; then
                debug "Closing window: $window_id"
                tm send-keys -t "${window_id}.0" C-c 2>/dev/null || true
                sleep 0.2
                tm kill-window -t "$window_id" 2>/dev/null || true
            fi
        fi

        # Clean up task (worktree, branch, agent dir)
        cleanup_task "$task_name" "$PROJECT_DIR" "$agent_dir" true

        echo "✅ Cleaned up merged task: $task_name"
    done
}

# Cleanup orphan windows (windows where agent_dir was deleted but window still exists)
cleanup_orphan_windows() {
    # Get all known window_ids from agent directories
    local known_window_ids=""
    if [ -d "$AGENTS_DIR" ]; then
        for agent_dir in "$AGENTS_DIR"/*/; do
            [ -d "$agent_dir" ] || continue
            local window_id_file="$agent_dir/.tab-lock/window_id"
            if [ -f "$window_id_file" ]; then
                local wid=$(cat "$window_id_file")
                known_window_ids="$known_window_ids $wid"
            fi
        done
    fi

    # Get all windows and check for orphans
    local windows
    windows=$(tm list-windows -F "#{window_id} #{window_name}" 2>/dev/null) || return 0

    echo "$windows" | while IFS= read -r line; do
        [ -z "$line" ] && continue
        local window_id=$(echo "$line" | awk '{print $1}')
        local window_name=$(echo "$line" | cut -d' ' -f2-)

        # Skip if not a task window (task windows start with emoji)
        case "$window_name" in
            ${EMOJI_WORKING}*|${EMOJI_WAITING}*|${EMOJI_DONE}*|${EMOJI_WARNING}*) ;;
            *) continue ;;
        esac

        # Check if this window_id is known
        if ! echo "$known_window_ids" | grep -q "$window_id"; then
            log "Closing orphan window: $window_name"
            debug "Orphan window_id: $window_id (not in known: $known_window_ids)"
            tm send-keys -t "${window_id}.0" C-c 2>/dev/null || true
            sleep 0.2
            tm kill-window -t "$window_id" 2>/dev/null || true
            echo "✅ Closed orphan window: $window_name"
        fi
    done
}

# Reopen incomplete tasks (tasks where window was closed but not done)
reopen_incomplete_tasks() {
    local incomplete_tasks
    incomplete_tasks=$(find_incomplete_tasks "$AGENTS_DIR" "$SESSION_NAME")

    [ -z "$incomplete_tasks" ] && return 0

    echo "$incomplete_tasks" | while IFS= read -r agent_dir; do
        [ -z "$agent_dir" ] && continue
        local task_name=$(basename "$agent_dir")
        log "Reopening incomplete task: $task_name"
        debug "Reopening: $agent_dir"

        # Use handle-task with --reopen --no-input flags
        nohup "$TAW_HOME/_taw/bin/handle-task" --reopen --no-input "$agent_dir" >> "$TAW_DIR/log" 2>&1 &
    done
}

# Ensure ⭐️main window exists and is at leftmost position (index 0)
ensure_main_window() {
    local main_exists
    main_exists=$(tm list-windows -t "$SESSION_NAME" -F "#{window_name}" 2>/dev/null | grep -c "^⭐️main$" || true)

    if [ "$main_exists" -eq 0 ]; then
        log "Creating ⭐️main window..."
        # Create at index 0
        tm new-window -t "$SESSION_NAME:0" -n "⭐️main" -c "$PROJECT_DIR"
        # Run new-task in it (loop so it restarts after each task)
        tm send-keys -t "$SESSION_NAME:⭐️main" "while true; do '$TAW_HOME/_taw/bin/new-task' || true; done" Enter
    else
        # Ensure it's at index 0 (leftmost)
        local main_index
        main_index=$(tm list-windows -t "$SESSION_NAME" -F "#{window_index} #{window_name}" 2>/dev/null | grep "⭐️main$" | awk '{print $1}')
        if [ "$main_index" != "0" ]; then
            debug "Moving ⭐️main from index $main_index to 0"
            tm move-window -s "$SESSION_NAME:⭐️main" -t "$SESSION_NAME:0"
        fi
    fi
}

# Reopen corrupted tasks (tasks where worktree state is invalid)
reopen_corrupted_tasks() {
    # Only check in git mode
    [ "$IS_GIT_REPO" = true ] || return 0

    local corrupted_tasks
    corrupted_tasks=$(find_corrupted_tasks "$AGENTS_DIR" "$PROJECT_DIR" "$SESSION_NAME")

    [ -z "$corrupted_tasks" ] && return 0

    echo "$corrupted_tasks" | while IFS='|' read -r agent_dir status; do
        [ -z "$agent_dir" ] && continue
        local task_name=$(basename "$agent_dir")
        log "Found corrupted task: $task_name (status: $status)"
        debug "Corrupted task: $agent_dir (status: $status)"

        # Create warning window with recovery script
        local display_name=$(truncate_name "$task_name")
        local window_name="${EMOJI_WARNING}${display_name}"

        debug "Creating warning window for corrupted task..."
        tm new-window -d -t "$SESSION_NAME" -n "$window_name" -c "$PROJECT_DIR" \
            "$TAW_HOME/_taw/bin/recover-task '$agent_dir' '$status'"
    done
}

# Configure tmux settings and keybindings
# Can be called on new session or reattach to ensure bindings are up to date
setup_tmux_config() {
    # Configure tmux session
    tm set -t "$SESSION_NAME" mouse on

    # Highlight focused pane with distinct styling
    # Active pane: bright green border (highly visible)
    # Inactive pane: dim gray border
    # Also dim inactive panes slightly to make active pane stand out
    tm set -t "$SESSION_NAME" pane-border-style "fg=colour238"
    tm set -t "$SESSION_NAME" pane-active-border-style "fg=green,bold"
    tm set -t "$SESSION_NAME" window-style "bg=colour233"           # Inactive pane: slightly dimmed
    tm set -t "$SESSION_NAME" window-active-style "bg=terminal"     # Active pane: normal background

    # Unbind root table keys only (preserve prefix table to avoid "table prefix doesn't exist" error)
    # All bindings use Alt key to avoid conflicts with shell keybindings
    tm unbind-key -T root -a 2>/dev/null || true

    # Core navigation
    tm bind -n M-Tab select-pane -t :.+     # Cycle panes
    tm bind -n M-Left previous-window       # Previous window
    tm bind -n M-Right next-window          # Next window

    # Task management: Alt + key
    # M-n: focus main window (⭐️main) where new-task runs
    tm bind -n M-n run-shell "tmux -L 'taw-$SESSION_NAME' select-window -t '$SESSION_NAME:⭐️main'"
    tm bind -n M-e run-shell "tmux -L 'taw-$SESSION_NAME' send-keys -t ':.1' \"$TAW_HOME/_taw/bin/end-task-ui '$SESSION_NAME' '#{window_id}'\" Enter"
    tm bind -n M-p run-shell "$TAW_HOME/_taw/bin/popup-shell '$SESSION_NAME'"
    tm bind -n M-u run-shell "$TAW_HOME/_taw/bin/quick-task '$SESSION_NAME'"
    tm bind -n M-m run-shell "$TAW_HOME/_taw/bin/merge-completed '$SESSION_NAME'"
    tm bind -n M-q detach
    tm bind -n M-/ run-shell "$TAW_HOME/_taw/bin/toggle-help '$SESSION_NAME'"
    tm bind -n M-h run-shell "$TAW_HOME/_taw/bin/toggle-help '$SESSION_NAME'"
    tm bind -n M-l run-shell "$TAW_HOME/_taw/bin/toggle-log '$SESSION_NAME'"

    # Status line: 2 lines - windows on top, hints on bottom
    tm set -t "$SESSION_NAME" status 2
    tm set -t "$SESSION_NAME" status-format[0] "#[align=left]#{W:#[fg=white bg=default] #W #[default],#[fg=white bg=blue bold] #W #[default]}"
    tm set -t "$SESSION_NAME" status-format[1] "#[align=left fg=brightblack] ⌥tab:pane  ⌥←→:window  ⌥n:main  ⌥e:end  ⌥m:merge  ⌥p:popup  ⌥l:log  ⌥u:queue  ⌥q:quit  ⌥h:help"

    debug "Tmux config and keybindings applied"
}

start_session() {
    check_dependencies

    # Create directories
    mkdir -p "$AGENTS_DIR"

    # Initialize logging
    init_logging "$TAW_DIR" "taw"

    log "=== Session start ==="
    log "Project: $PROJECT_NAME"
    log "Directory: $PROJECT_DIR"
    log "TAW Directory: $TAW_DIR"

    # Clean up tab markers from previous session
    find "$AGENTS_DIR" -name ".tab-created" -delete 2>/dev/null

    echo "Starting session '$SESSION_NAME'..."

    # Start tmux session with ⭐️main window at index 0
    cd "$PROJECT_DIR"
    tm new-session -d -s "$SESSION_NAME" -n "⭐️main" -c "$PROJECT_DIR"
    log "Tmux session created: $SESSION_NAME"

    # Apply tmux configuration and keybindings
    setup_tmux_config
    log "Tmux configured"

    # Run new-task in the main window (loop so it restarts after each task)
    debug "Running new-task in ⭐️main window..."
    tm send-keys -t "$SESSION_NAME:⭐️main" "while true; do '$TAW_HOME/_taw/bin/new-task' || true; done" Enter

    # Auto-cleanup merged tasks (before reopening, so merged tasks are cleaned up first)
    debug "Checking for merged tasks to cleanup..."
    auto_cleanup_merged_tasks

    # Cleanup orphan windows (agent_dir deleted but window still open)
    debug "Checking for orphan windows..."
    cleanup_orphan_windows

    # Reopen any incomplete tasks from previous sessions
    debug "Checking for incomplete tasks..."
    reopen_incomplete_tasks

    # Check for corrupted worktree states
    debug "Checking for corrupted worktrees..."
    reopen_corrupted_tasks

    # Attach to session
    log "Attaching to session"
    printf '\e]1;%s\a' "taw: $SESSION_NAME"
    tm attach -t "$SESSION_NAME"
}

# === Main ===

# Handle clean command (can run inside tmux)
if [ "$COMMAND" = "clean" ]; then
    clean_all
    exit 0
fi

# Handle setup command (reconfigure existing project)
if [ "$COMMAND" = "setup" ]; then
    detect_git_repo
    if [ ! -d "$TAW_DIR" ]; then
        echo "Error: .taw directory not found. Run 'taw' first to initialize."
        exit 1
    fi
    "$TAW_HOME/_taw/bin/setup" "$TAW_DIR" "$IS_GIT_REPO"
    exit 0
fi

# Check if already inside tmux session
if [ -n "$TMUX" ]; then
    echo "Already inside tmux session. Ignoring."
    exit 0
fi

# Detect git repo and initialize
debug "Detecting git repo..."
detect_git_repo
debug "IS_GIT_REPO=$IS_GIT_REPO"
debug "Initializing taw directory..."
init_taw_dir
debug "TAW_DIR=$TAW_DIR"
if [ "$IS_GIT_REPO" = true ]; then
    update_gitignore
fi

# Initialize logging (before any log calls)
init_logging "$TAW_DIR" "taw"

# Export TAW_HOME and TAW_DEBUG for child scripts
export TAW_HOME TAW_DEBUG

# If session exists, attach to it; otherwise start new
if is_session_running; then
    log "Reattaching to existing session: $SESSION_NAME"
    echo "Attaching to existing session '$SESSION_NAME'..."

    # Auto-cleanup merged tasks (before reopening, so merged tasks are cleaned up first)
    debug "Checking for merged tasks to cleanup..."
    auto_cleanup_merged_tasks

    # Cleanup orphan windows (agent_dir deleted but window still open)
    debug "Checking for orphan windows..."
    cleanup_orphan_windows

    # Check if session still exists after cleanup (all windows might have been closed)
    if ! is_session_running; then
        log "Session terminated after cleanup, starting fresh..."
        start_session
    else
        # Update tmux config and keybindings (ensures latest bindings on reattach)
        setup_tmux_config

        # Ensure ⭐️main window exists (reopen if closed) and is at leftmost
        debug "Ensuring main window..."
        ensure_main_window

        # Reopen any incomplete tasks
        debug "Checking for incomplete tasks..."
        reopen_incomplete_tasks

        # Check for corrupted worktree states
        debug "Checking for corrupted worktrees..."
        reopen_corrupted_tasks

        printf '\e]1;%s\a' "taw: $SESSION_NAME"
        tm attach -t "$SESSION_NAME"
    fi
else
    start_session
fi
