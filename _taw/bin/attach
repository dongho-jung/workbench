#!/bin/bash

# TAW Attach - Reattach to an existing task
# Creates window with agent pane and starts claude
# Works with both git and non-git modes

set -e

# Determine paths from script location (attach is symlinked into agent dir)
SCRIPT_PATH="$(cd "$(dirname "$0")" && pwd)"
AGENT_DIR="$SCRIPT_PATH"
TASK_NAME="$(basename "$AGENT_DIR")"
TAW_DIR="$(cd "$AGENT_DIR/../.." && pwd)"
PROJECT_DIR="$(cd "$TAW_DIR/.." && pwd)"
WORKTREE_DIR="$AGENT_DIR/worktree"

# Find TAW_HOME by reading the symlink target of new-task
if [ -L "$TAW_DIR/new-task" ]; then
    NEW_TASK_TARGET="$(readlink "$TAW_DIR/new-task")"
    TAW_HOME="$(cd "$(dirname "$NEW_TASK_TARGET")/../.." && pwd)"
else
    echo "Error: Cannot determine TAW_HOME"
    exit 1
fi

# Source common utilities
source "$TAW_HOME/_taw/bin/_common.sh"

PROJECT_NAME="$(basename "$PROJECT_DIR")"
SESSION_NAME="$PROJECT_NAME"

# Check if this is git mode
IS_GIT_MODE=false
if [ -f "$TAW_DIR/.is-git-repo" ]; then
    IS_GIT_MODE=true
fi

# Use .global-prompt symlink (consistent with handle-task)
GLOBAL_PROMPT="$TAW_DIR/.global-prompt"
PROJECT_PROMPT="$TAW_DIR/PROMPT.md"

# Check if inside tmux
if [ -z "$TMUX" ]; then
    echo "Error: Not inside tmux session."
    echo "Run 'taw' first to start the session."
    exit 1
fi

# Check if session matches
CURRENT_SESSION="$(tmux display-message -p '#S')"
if [ "$CURRENT_SESSION" != "$SESSION_NAME" ]; then
    echo "Error: Current session '$CURRENT_SESSION' doesn't match project session '$SESSION_NAME'"
    exit 1
fi

# Set working directory based on git mode
if [ "$IS_GIT_MODE" = true ]; then
    WORK_DIR="$WORKTREE_DIR"
    # Check if worktree exists, create if not
    if [ ! -d "$WORKTREE_DIR" ]; then
        echo "Creating worktree..."
        git -C "$PROJECT_DIR" worktree prune 2>/dev/null || true
        if ! git -C "$PROJECT_DIR" worktree add "$WORKTREE_DIR" -b "$TASK_NAME" 2>/dev/null; then
            if ! git -C "$PROJECT_DIR" worktree add "$WORKTREE_DIR" "$TASK_NAME" 2>/dev/null; then
                echo "Error: Failed to create worktree"
                exit 1
            fi
        fi
    fi
else
    # Non-git mode: work directly in project directory
    WORK_DIR="$PROJECT_DIR"
fi

# Build system prompt
system_prompt=""
if [ -f "$GLOBAL_PROMPT" ]; then
    system_prompt=$(cat "$GLOBAL_PROMPT")
fi
if [ -f "$PROJECT_PROMPT" ]; then
    if [ -n "$system_prompt" ]; then
        system_prompt="$system_prompt"$'\n\n---\n\n'
    fi
    system_prompt="$system_prompt$(cat "$PROJECT_PROMPT")"
fi

# Save system prompt
echo "$system_prompt" > "$AGENT_DIR/.system-prompt"

display_name=$(truncate_name "$TASK_NAME")
window_name="${EMOJI_WORKING}${display_name}"

# Create new window
window_id=$(tmux new-window -n "$window_name" -c "$WORK_DIR" -P -F "#{window_id}")
sleep 0.3

# Split horizontally for user pane
tmux split-window -t "$window_id" -h -c "$WORK_DIR"

# Select agent pane (left)
tmux select-pane -t "${window_id}.0"

# Helper functions for claude interaction
get_pane_content() {
    tmux capture-pane -t "${window_id}.0" -p 2>/dev/null || echo ""
}

wait_for_claude_ready() {
    local max_attempts=$CLAUDE_READY_MAX_ATTEMPTS
    local attempt=0
    debug "Waiting for claude to be ready (max $max_attempts attempts)..."
    while [ $attempt -lt $max_attempts ]; do
        local content=$(get_pane_content)
        # Claude is ready when we see trust prompt, input prompt, or bypass permissions
        if echo "$content" | grep -qE "Trust|trust|╭─|^> $|bypass permissions"; then
            debug "Claude ready after $attempt attempts"
            return 0
        fi
        sleep $CLAUDE_READY_POLL_INTERVAL
        attempt=$((attempt + 1))
    done
    debug "TIMEOUT waiting for claude after $max_attempts attempts"
    return 1
}

send_shell_cmd() {
    tmux send-keys -t "${window_id}.0" -l "$1"
    tmux send-keys -t "${window_id}.0" Enter
}

# Start claude with system prompt (include WINDOW_ID, WORKTREE_DIR only in git mode)
# Note: paths are single-quoted to handle spaces correctly
debug "Starting claude with system prompt..."
if [ "$IS_GIT_MODE" = true ]; then
    send_shell_cmd "export TASK_NAME='$TASK_NAME' TAW_DIR='$TAW_DIR' PROJECT_DIR='$PROJECT_DIR' WORKTREE_DIR='$WORK_DIR' WINDOW_ID='$window_id' && claude --dangerously-skip-permissions --system-prompt \"\$(cat '$AGENT_DIR/.system-prompt')\""
else
    send_shell_cmd "export TASK_NAME='$TASK_NAME' TAW_DIR='$TAW_DIR' PROJECT_DIR='$PROJECT_DIR' WINDOW_ID='$window_id' && claude --dangerously-skip-permissions --system-prompt \"\$(cat '$AGENT_DIR/.system-prompt')\""
fi

# Wait for claude to be ready
debug "Waiting for claude to start..."
if ! wait_for_claude_ready; then
    warn "Timeout waiting for claude to start"
fi

# Check if trust confirmation is needed
screen_content=$(get_pane_content)
if echo "$screen_content" | grep -qiE "trust|Trust this project|y/n|\[y\]|Are you sure"; then
    debug "Trust confirmation needed, sending 'y'"
    send_shell_cmd "y"
    wait_for_claude_ready || true
fi

echo "Attached to task: $TASK_NAME"
