#!/bin/bash

# TAW Log Viewer - Simple interactive log file viewer
#
# Features:
#   - ↑/↓ (or j/k): Scroll up/down
#   - PgUp/PgDn: Page up/down
#   - Home/g: Go to top
#   - End/G: Go to bottom
#   - s: Toggle tail (auto-scroll) mode
#   - q, Esc: Quit

LOG_FILE="${1:-}"
SESSION_NAME="${2:-}"

if [ -z "$LOG_FILE" ]; then
    echo "Usage: log-viewer LOG_FILE [SESSION_NAME]" >&2
    exit 1
fi

if [ ! -f "$LOG_FILE" ]; then
    echo "Error: Log file not found: $LOG_FILE" >&2
    exit 1
fi

# Terminal setup
cleanup() {
    tput cnorm 2>/dev/null || true
    stty "$SAVED_STTY" 2>/dev/null || true
    tput rmcup 2>/dev/null || true

    if [ -n "$SESSION_NAME" ]; then
        tmux -L "taw-$SESSION_NAME" set-option -g @taw_log_open '' 2>/dev/null || true
    fi
}

trap cleanup EXIT INT TERM

# Handle terminal resize
handle_resize() {
    get_dimensions
    local total=${#LINES_CACHE[@]}
    local max=$((total - CONTENT_LINES))
    [ $max -lt 0 ] && max=0
    [ $SCROLL_POS -gt $max ] && SCROLL_POS=$max
    clear_screen
    redraw
}
trap handle_resize WINCH

# Save terminal state and setup raw mode
SAVED_STTY=$(stty -g 2>/dev/null || echo "")
stty raw -echo min 0 time 5 2>/dev/null || true
tput smcup 2>/dev/null || true
tput civis 2>/dev/null || true

# Disable mouse tracking to allow text selection
printf '\033[?1000l\033[?1002l\033[?1003l\033[?1006l'

# State variables
SCROLL_POS=0
TAIL_MODE=true
FILE_MTIME=""

# Global array
LINES_CACHE=()

# Get terminal dimensions
get_dimensions() {
    TERM_LINES=$(tput lines 2>/dev/null || echo 24)
    TERM_COLS=$(tput cols 2>/dev/null || echo 80)
    CONTENT_LINES=$((TERM_LINES - 1))  # Reserve 1 line for status bar
    [ "$CONTENT_LINES" -lt 1 ] && CONTENT_LINES=1
    [ "$TERM_COLS" -lt 10 ] && TERM_COLS=10
}

# Load log file into array
load_file() {
    local i=0
    LINES_CACHE=()

    while IFS= read -r line || [ -n "$line" ]; do
        LINES_CACHE[i]="$line"
        ((i++)) || true
    done < "$LOG_FILE"

    FILE_MTIME=$(stat -f%m "$LOG_FILE" 2>/dev/null || stat -c%Y "$LOG_FILE" 2>/dev/null || echo "0")
}

# Cursor movement
move() {
    printf '\033[%d;%dH' "$1" "$2"
}

# Clear screen
clear_screen() {
    printf '\033[2J'
    move 1 1
}

# Truncate line if needed
truncate_line() {
    local line="$1"
    local max_len=$((TERM_COLS - 1))

    if [ ${#line} -gt $max_len ]; then
        printf '%s' "${line:0:$((max_len - 3))}..."
    else
        printf '%s' "$line"
    fi
}

# Draw status bar
draw_status() {
    local total=${#LINES_CACHE[@]}
    local end_pos=$((SCROLL_POS + CONTENT_LINES))
    [ $end_pos -gt $total ] && end_pos=$total
    [ $total -eq 0 ] && end_pos=0

    move $TERM_LINES 1
    printf '\033[7m'  # Inverse video

    local status=""
    if [ "$TAIL_MODE" = true ]; then
        status="[TAIL] "
    fi

    local start_line=0
    [ $total -gt 0 ] && start_line=$((SCROLL_POS + 1))
    local pos_info="Lines $start_line-$end_pos of $total"

    printf "%-${TERM_COLS}s" "${status}${pos_info}"
    printf '\033[0m'
}

# Draw content
draw_content() {
    local total=${#LINES_CACHE[@]}
    local start=$SCROLL_POS

    local i
    for ((i = 0; i < CONTENT_LINES; i++)); do
        move $((i + 1)) 1
        printf '\033[K'

        local line_idx=$((start + i))
        if [ $line_idx -lt $total ]; then
            truncate_line "${LINES_CACHE[$line_idx]}"
        fi
    done
}

# Full redraw
redraw() {
    get_dimensions
    draw_content
    draw_status
}

# Scroll to end
scroll_to_end() {
    get_dimensions
    local total=${#LINES_CACHE[@]}
    local max=$((total - CONTENT_LINES))
    [ $max -lt 0 ] && max=0
    SCROLL_POS=$max
}

# Check if file was updated
check_file_update() {
    local new_mtime
    new_mtime=$(stat -f%m "$LOG_FILE" 2>/dev/null || stat -c%Y "$LOG_FILE" 2>/dev/null || echo "0")

    if [ "$new_mtime" != "$FILE_MTIME" ]; then
        return 0
    fi
    return 1
}

# Main loop
main() {
    get_dimensions
    load_file
    scroll_to_end
    clear_screen
    redraw

    while true; do
        # Check for file updates in tail mode
        if [ "$TAIL_MODE" = true ]; then
            if check_file_update; then
                load_file
                scroll_to_end
                redraw
            fi
        fi

        # Read key
        local key=""
        IFS= read -r -n1 key 2>/dev/null || true

        [ -z "$key" ] && continue

        # Handle escape sequences
        if [ "$key" = $'\033' ]; then
            local seq1="" seq2="" seq3=""

            stty raw -echo min 0 time 1 2>/dev/null || true
            IFS= read -r -n1 seq1 2>/dev/null || true

            if [ "$seq1" = "[" ]; then
                IFS= read -r -n1 seq2 2>/dev/null || true
                case "$seq2" in
                    A) key="UP" ;;
                    B) key="DOWN" ;;
                    H) key="HOME" ;;
                    F) key="END" ;;
                    5) IFS= read -r -n1 seq3 2>/dev/null || true; [ "$seq3" = "~" ] && key="PGUP" ;;
                    6) IFS= read -r -n1 seq3 2>/dev/null || true; [ "$seq3" = "~" ] && key="PGDN" ;;
                    1) IFS= read -r -n1 seq3 2>/dev/null || true; [ "$seq3" = "~" ] && key="HOME" ;;
                    4) IFS= read -r -n1 seq3 2>/dev/null || true; [ "$seq3" = "~" ] && key="END" ;;
                    *) key="ESC" ;;
                esac
            elif [ "$seq1" = "O" ]; then
                IFS= read -r -n1 seq2 2>/dev/null || true
                case "$seq2" in
                    H) key="HOME" ;;
                    F) key="END" ;;
                    *) key="ESC" ;;
                esac
            elif [ -z "$seq1" ]; then
                key="ESC"
            fi

            stty raw -echo min 0 time 5 2>/dev/null || true
        fi

        # Handle keys
        local total=${#LINES_CACHE[@]}
        local max=$((total - CONTENT_LINES))
        [ $max -lt 0 ] && max=0

        case "$key" in
            q|Q|ESC)
                break
                ;;
            j|DOWN)
                TAIL_MODE=false
                [ $SCROLL_POS -lt $max ] && ((SCROLL_POS++))
                redraw
                ;;
            k|UP)
                TAIL_MODE=false
                [ $SCROLL_POS -gt 0 ] && ((SCROLL_POS--))
                redraw
                ;;
            g|HOME)
                TAIL_MODE=false
                SCROLL_POS=0
                redraw
                ;;
            G|END)
                scroll_to_end
                redraw
                ;;
            PGUP)
                TAIL_MODE=false
                SCROLL_POS=$((SCROLL_POS - CONTENT_LINES))
                [ $SCROLL_POS -lt 0 ] && SCROLL_POS=0
                redraw
                ;;
            PGDN)
                SCROLL_POS=$((SCROLL_POS + CONTENT_LINES))
                [ $SCROLL_POS -gt $max ] && SCROLL_POS=$max
                redraw
                ;;
            s|S)
                if [ "$TAIL_MODE" = true ]; then
                    TAIL_MODE=false
                else
                    TAIL_MODE=true
                    load_file
                    scroll_to_end
                fi
                redraw
                ;;
        esac
    done
}

main
