#!/bin/bash

# TAW End Task UI
# User-facing script that shows progress in the user pane
# Calls end-task internally and displays status

set -e

# Source common utilities
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
source "$SCRIPT_DIR/_common.sh"

TAW_HOME=$(get_taw_home)

# Arguments
SESSION_NAME="$1"
WINDOW_ID="$2"
FORCE_MODE="$3"

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color
BOLD='\033[1m'

# Status indicators
SPINNER_CHARS=('â ‹' 'â ™' 'â ¹' 'â ¸' 'â ¼' 'â ´' 'â ¦' 'â §' 'â ‡' 'â ')

print_header() {
    echo ""
    echo -e "${BOLD}${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${BOLD}${CYAN}  End Task${NC}"
    echo -e "${BOLD}${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
}

print_step() {
    local status="$1"
    local message="$2"
    case "$status" in
        "start")
            echo -e "${BLUE}â—${NC} $message"
            ;;
        "ok")
            echo -e "${GREEN}âœ“${NC} $message"
            ;;
        "skip")
            echo -e "${YELLOW}â—‹${NC} $message ${YELLOW}(skipped)${NC}"
            ;;
        "fail")
            echo -e "${RED}âœ—${NC} $message ${RED}(failed)${NC}"
            ;;
        "warn")
            echo -e "${YELLOW}!${NC} $message"
            ;;
    esac
}

print_error() {
    echo ""
    echo -e "${RED}${BOLD}Error:${NC} $1"
    echo ""
}

print_success() {
    echo ""
    echo -e "${GREEN}${BOLD}âœ“ Task completed successfully${NC}"
    echo ""
}

# Validate arguments
if [ -z "$SESSION_NAME" ] || [ -z "$WINDOW_ID" ]; then
    print_error "Usage: end-task-ui <session_name> <window_id> [--force]"
    exit 1
fi

# Validate window exists and get current window for safety check
CURRENT_WINDOW=$(tm "$SESSION_NAME" display-message -p '#{window_id}' 2>/dev/null || echo "")
if [ "$CURRENT_WINDOW" != "$WINDOW_ID" ]; then
    print_error "Window mismatch: expected $WINDOW_ID but current is $CURRENT_WINDOW"
    echo "This can happen if you switched windows. Please try again."
    exit 1
fi

# Verify the window still exists
if ! tm "$SESSION_NAME" list-windows -F '#{window_id}' 2>/dev/null | grep -q "^${WINDOW_ID}$"; then
    print_error "Window $WINDOW_ID no longer exists"
    exit 1
fi

print_header

# Get task name from window
TASK_NAME=$(tm "$SESSION_NAME" display-message -t "$WINDOW_ID" -p '#{window_name}' 2>/dev/null | sed 's/^[ğŸ¤–ğŸ’¬âœ…âš ï¸]*//')
if [ -z "$TASK_NAME" ]; then
    print_error "Could not determine task name from window"
    exit 1
fi

echo -e "${BOLD}Task:${NC} $TASK_NAME"
echo ""

# Get pane path and find project directory
PANE_PATH=$(tm "$SESSION_NAME" display-message -t "$WINDOW_ID" -p '#{pane_current_path}' 2>/dev/null)
PROJECT_DIR=$(find_project_dir_from_path "$PANE_PATH")

if [ -z "$PROJECT_DIR" ]; then
    print_error "Could not find .taw directory"
    exit 1
fi

TAW_DIR="$PROJECT_DIR/.taw"
AGENT_DIR="$TAW_DIR/agents/$TASK_NAME"
WORKTREE_DIR="$AGENT_DIR/worktree"
LOG_FILE="$TAW_DIR/.metadata/log/end-task.log"

mkdir -p "$(dirname "$LOG_FILE")"
log "=== End task UI: $TASK_NAME ===" "$LOG_FILE"

# Check if agent directory exists
if [ ! -d "$AGENT_DIR" ]; then
    print_step "warn" "Agent directory not found"
    print_step "start" "Closing window..."
    tm "$SESSION_NAME" kill-window -t "$WINDOW_ID" 2>/dev/null || true
    print_success
    exit 0
fi

# Check if git mode
IS_GIT_MODE=false
if [ -f "$TAW_DIR/.is-git-repo" ]; then
    IS_GIT_MODE=true
fi

# Get ON_COMPLETE setting
ON_COMPLETE=$(read_config "$TAW_DIR" "on_complete" "$DEFAULT_ON_COMPLETE")
echo -e "${BOLD}Mode:${NC} $ON_COMPLETE"
echo ""

# Get work directory
WORK_DIR="$PROJECT_DIR"
if [ "$IS_GIT_MODE" = true ] && [ -d "$WORKTREE_DIR" ]; then
    WORK_DIR="$WORKTREE_DIR"
fi

# === Step 1: Commit uncommitted changes ===
if [ "$IS_GIT_MODE" = true ] && [ "$FORCE_MODE" != "--force" ] && [ -d "$WORK_DIR" ]; then
    cd "$WORK_DIR"

    if [ -n "$(git status -s 2>/dev/null)" ]; then
        print_step "start" "Committing changes..."
        git add -A
        DIFF_STAT=$(git diff --cached --stat 2>/dev/null | tail -1 || echo "changes")
        if git commit -m "chore: auto-commit on task end

$DIFF_STAT" 2>/dev/null; then
            print_step "ok" "Changes committed"
        else
            print_step "skip" "Nothing to commit"
        fi
    else
        print_step "skip" "No uncommitted changes"
    fi
fi

# === Step 2: PR/Merge based on ON_COMPLETE ===
MERGED=false

if [ "$IS_GIT_MODE" = true ] && [ "$FORCE_MODE" != "--force" ] && [ -d "$WORK_DIR" ]; then
    cd "$WORK_DIR"

    case "$ON_COMPLETE" in
        auto-merge)
            print_step "start" "Pushing branch..."
            if git push -u origin "$TASK_NAME" 2>/dev/null; then
                print_step "ok" "Branch pushed"
            else
                print_step "warn" "Push failed (may already be pushed)"
            fi

            MAIN_BRANCH=$(git -C "$PROJECT_DIR" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")

            print_step "start" "Checking out $MAIN_BRANCH..."
            git -C "$PROJECT_DIR" fetch origin "$MAIN_BRANCH" 2>/dev/null || true

            if ! git -C "$PROJECT_DIR" checkout "$MAIN_BRANCH" 2>/dev/null; then
                print_step "fail" "Failed to checkout $MAIN_BRANCH"
                print_error "Resolve manually or use âŒ¥ e --force to skip"
                exit 1
            fi
            print_step "ok" "Checked out $MAIN_BRANCH"

            print_step "start" "Pulling latest..."
            git -C "$PROJECT_DIR" pull origin "$MAIN_BRANCH" 2>/dev/null || true
            print_step "ok" "Pulled latest"

            print_step "start" "Merging $TASK_NAME..."
            if git -C "$PROJECT_DIR" merge "$TASK_NAME" --no-ff -m "Merge branch '$TASK_NAME'" 2>/dev/null; then
                print_step "ok" "Merged to $MAIN_BRANCH"

                print_step "start" "Pushing to remote..."
                if git -C "$PROJECT_DIR" push origin "$MAIN_BRANCH" 2>/dev/null; then
                    print_step "ok" "Pushed to remote"
                else
                    print_step "warn" "Push to remote failed"
                fi
                MERGED=true
            else
                git -C "$PROJECT_DIR" merge --abort 2>/dev/null || true
                print_step "fail" "Merge conflict!"
                print_error "Resolve conflicts manually or use âŒ¥ e --force to skip"
                exit 1
            fi
            ;;

        auto-pr)
            print_step "start" "Pushing branch..."
            git push -u origin "$TASK_NAME" 2>/dev/null || true
            print_step "ok" "Branch pushed"

            if ! gh pr view 2>/dev/null; then
                print_step "start" "Creating PR..."
                PR_TITLE="$TASK_NAME"
                PR_BODY="## Summary
- Task: $TASK_NAME

## Changes
$(git log --oneline origin/main..$TASK_NAME 2>/dev/null || echo "- See commits")"

                if gh pr create --title "$PR_TITLE" --body "$PR_BODY" 2>/dev/null; then
                    gh pr view --json number -q '.number' > "$AGENT_DIR/.pr" 2>/dev/null || true
                    print_step "ok" "PR created"
                else
                    print_step "fail" "Failed to create PR"
                fi
            else
                print_step "skip" "PR already exists"
            fi

            # Check if merged
            PR_FILE="$AGENT_DIR/.pr"
            if [ -f "$PR_FILE" ]; then
                PR_NUMBER=$(cat "$PR_FILE")
                PR_STATE=$(gh pr view "$PR_NUMBER" --json merged -q '.merged' 2>/dev/null || echo "false")
                if [ "$PR_STATE" = "true" ]; then
                    MERGED=true
                    print_step "ok" "PR is merged"
                fi
            fi
            ;;

        auto-commit|confirm|*)
            print_step "start" "Pushing branch..."
            if git push -u origin "$TASK_NAME" 2>/dev/null; then
                print_step "ok" "Branch pushed"
            else
                print_step "warn" "Push failed"
            fi
            ;;
    esac
fi

# === Step 3: Check merge status ===
if [ "$IS_GIT_MODE" = true ] && [ "$FORCE_MODE" != "--force" ] && [ "$MERGED" = false ]; then
    PR_FILE="$AGENT_DIR/.pr"
    if [ -f "$PR_FILE" ]; then
        PR_NUMBER=$(cat "$PR_FILE")
        PR_STATE=$(gh pr view "$PR_NUMBER" --json merged -q '.merged' 2>/dev/null || echo "false")
        if [ "$PR_STATE" = "true" ]; then
            MERGED=true
            print_step "ok" "PR #$PR_NUMBER is merged"
        fi
    fi

    if [ "$MERGED" = false ]; then
        git -C "$PROJECT_DIR" fetch origin main 2>/dev/null || true
        if git -C "$PROJECT_DIR" branch --merged main 2>/dev/null | grep -q "\\b$TASK_NAME\\b"; then
            MERGED=true
            print_step "ok" "Branch is merged to main"
        fi
    fi

    # If not merged and not auto-merge, ask
    if [ "$MERGED" = false ] && [ "$ON_COMPLETE" != "auto-merge" ]; then
        echo ""
        echo -e "${YELLOW}Task is NOT merged.${NC}"
        read -p "Delete anyway? [y/N] " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Cancelled."
            exit 0
        fi
    fi
fi

# === Step 4: Cleanup ===
echo ""
print_step "start" "Stopping Claude..."
tm "$SESSION_NAME" send-keys -t "${WINDOW_ID}.0" C-c 2>/dev/null || true
sleep 0.3
tm "$SESSION_NAME" send-keys -t "${WINDOW_ID}.0" C-c 2>/dev/null || true
sleep 0.3
print_step "ok" "Claude stopped"

print_step "start" "Cleaning up task..."
cleanup_task "$TASK_NAME" "$PROJECT_DIR" "$AGENT_DIR" "$IS_GIT_MODE"
print_step "ok" "Task cleaned up"

print_step "start" "Closing window..."
# Note: We're in pane 1 (user pane), killing window will close both panes
tm "$SESSION_NAME" kill-window -t "$WINDOW_ID" 2>/dev/null || true

log "End task UI completed: $TASK_NAME" "$LOG_FILE"

# Process queue
"$TAW_HOME/_taw/bin/process-queue" "$SESSION_NAME" &

print_success
