#!/bin/bash

# TAW New Task Creator
# Creates a new task in .taw/agents directory

set -e

# Source common utilities
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
source "$SCRIPT_DIR/_common.sh"

TAW_HOME=$(get_taw_home)
export TAW_HOME  # Export for child processes (handle-task)

PROJECT_DIR="$(pwd)"
TAW_DIR="$PROJECT_DIR/.taw"
AGENTS_DIR="$TAW_DIR/agents"

# Check if .taw directory exists
if [ ! -d "$TAW_DIR" ]; then
    echo "Error: .taw directory not found."
    echo "Run 'taw' first to initialize the project."
    exit 1
fi

# Initialize logging
init_logging "$TAW_DIR" "new-task"

# Ensure directories exist
mkdir -p "$AGENTS_DIR"

# Create temp file for editing with hint
temp_file=$(mktemp) || {
    echo "Error: Failed to create temp file"
    exit 1
}
trap "stop_spinner; rm -f '$temp_file'" EXIT
debug "Created temp file: $temp_file"

# Add hint comment
cat > "$temp_file" << 'EOF'
# 에이전트에게 시킬 일 적고 저장
# ⌥/ 로 도움말 보기

EOF

# Determine editor and options
editor="${EDITOR:-vim}"
debug "Using editor: $editor"

# Check if editor exists
if ! command -v "$editor" &>/dev/null; then
    echo "Error: Editor '$editor' not found. Set \$EDITOR to a valid editor."
    exit 1
fi

# If editor is vi/vim/nvim, start on line 3 in insert mode
editor_args=()
if [[ "$editor" =~ (^|/)n?vim?$ ]]; then
    editor_args+=("-c" "normal! 3G" "-c" "startinsert")
fi

# Open editor
debug "Opening editor..."
if ! "$editor" "${editor_args[@]}" "$temp_file"; then
    echo "Error: Editor exited with error"
    exit 1
fi
debug "Editor closed"

# Read task content, filtering out comment lines (starting with #)
# Use || true to prevent set -e from exiting when all lines are comments
task_content=$(grep -v '^[[:space:]]*#' "$temp_file" || true)

# Check if content exists after filtering (ignore empty lines for this check)
if [ -z "$(echo "$task_content" | tr -d '[:space:]')" ]; then
    echo "No content written. Task cancelled."
    log "Task cancelled: no content"
    exit 1
fi

log "Task content received, calling Claude CLI (haiku)..."
debug "Task content: $task_content"

# Start spinner while generating task name
start_spinner "태스크 이름 생성 중..."

# Call Claude CLI to generate task name
# Use single-line prompt for reliability
base_prompt="Create a task name for: '$task_content'. Reply with ONLY the task name, nothing else. Rules: 8-32 chars, lowercase letters and hyphens only, format verb-noun like fix-auth-bug"

# Generate task name with timeout and retry (3s, 5s, 10s)
timeouts=(3 5 10)
task_name=""
last_error=""

for i in "${!timeouts[@]}"; do
    timeout_sec="${timeouts[$i]}"
    attempt=$((i + 1))
    debug "Attempt $attempt: calling claude CLI (timeout: ${timeout_sec}s)..."

    # Add error feedback on retry
    if [ -n "$last_error" ]; then
        prompt="$base_prompt. IMPORTANT: Your previous response '$last_error' was invalid. Reply with ONLY a valid task name."
    else
        prompt="$base_prompt"
    fi

    if [ "${TAW_DEBUG:-0}" = "1" ]; then
        result=$(echo "$prompt" | timeout "$timeout_sec" claude -p --model haiku 2>&1 | tee /dev/stderr | tr -d '[:space:]') || true
    else
        result=$(echo "$prompt" | timeout "$timeout_sec" claude -p --model haiku 2>/dev/null | tr -d '[:space:]') || true
    fi

    debug "Claude CLI returned: '$result'"

    # Validate: 8-32 chars, lowercase letters, numbers, hyphens, no leading/trailing hyphens
    if [[ "$result" =~ ^[a-z0-9][a-z0-9-]{6,30}[a-z0-9]$ ]]; then
        task_name="$result"
        log "Generated task name: $task_name (attempt $attempt)"
        break
    else
        log "Attempt $attempt failed: invalid name '$result'"
        debug "Invalid task name, retrying..."
        last_error="$result"
    fi
done

# Fallback to timestamp if all attempts failed
if [ -z "$task_name" ]; then
    timestamp=$(date '+%y%m%d%H%M%S')
    echo "Warning: Failed to generate valid task name after 3 attempts. Using timestamp."
    log "All attempts failed, using fallback: task-$timestamp"
    task_name="task-$timestamp"
fi

# Stop spinner - task name generation complete
stop_spinner

# Atomic directory creation - mkdir (without -p) fails if directory exists
# This prevents race conditions when multiple tasks are created simultaneously
create_task_atomically() {
    local base_name="$1"
    local content="$2"
    local final_name="$base_name"
    local counter=1
    local max_attempts=100

    while [ $counter -le $max_attempts ]; do
        local agent_dir="$AGENTS_DIR/$final_name"
        debug "Trying to create agent directory: $agent_dir"
        # mkdir without -p fails if directory exists (atomic check-and-create)
        if mkdir "$agent_dir" 2>/dev/null; then
            echo "$content" > "$agent_dir/task"
            echo "$agent_dir"
            return 0
        fi
        # Directory exists, try next name
        debug "Directory exists, trying next name"
        final_name="${base_name}-${counter}"
        counter=$((counter + 1))
    done

    return 1
}

agent_dir=$(create_task_atomically "$task_name" "$task_content")

if [ -z "$agent_dir" ] || [ ! -d "$agent_dir" ]; then
    echo "Failed to create task directory after multiple attempts"
    log "Failed to create task directory for: $task_name"
    exit 1
fi

final_name=$(basename "$agent_dir")

echo "Task created: $agent_dir"
log "Task created: $final_name"

# Start the agent in background (handle-task creates window and runs claude)
# Use nohup to ensure process survives parent exit
debug "Calling handle-task: $agent_dir (background)"
nohup "$TAW_HOME/_taw/bin/handle-task" "$agent_dir" >> "$TAW_DIR/log" 2>&1 &

# Wait for handle-task to create window (check for .tab-lock/window_id)
# This prevents the _ window from closing before new window is created
window_id_file="$agent_dir/.tab-lock/window_id"
max_wait=30  # 30 seconds max
waited=0
debug "Waiting for window to be created..."
while [ ! -f "$window_id_file" ] && [ $waited -lt $max_wait ]; do
    sleep 0.5
    waited=$((waited + 1))
    if [ $((waited % 10)) -eq 0 ]; then
        debug "Still waiting for window... ($waited attempts)"
    fi
done

if [ -f "$window_id_file" ]; then
    debug "Window created: $(cat "$window_id_file")"
    log "Window created successfully"
else
    log "Warning: Timed out waiting for window creation"
    debug "Timeout waiting for window, continuing anyway..."
fi
