#!/bin/bash

# TAW Recover Task
# Interactive recovery for corrupted worktree states
# Shows status and lets user choose: recover or cleanup

set -e

# Source common utilities
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
source "$SCRIPT_DIR/_common.sh"

# Parse arguments
if [ $# -lt 2 ]; then
    echo "Usage: recover-task <agent-directory> <status>"
    echo "Status: missing_worktree | not_in_git | invalid_git | missing_branch"
    exit 1
fi

AGENT_DIR="$1"
CORRUPTED_STATUS="$2"

if [ ! -d "$AGENT_DIR" ]; then
    echo "Error: Agent directory not found: $AGENT_DIR"
    exit 1
fi

# Derive paths
TASK_NAME=$(basename "$AGENT_DIR")
AGENTS_DIR=$(dirname "$AGENT_DIR")
TAW_DIR=$(dirname "$AGENTS_DIR")
PROJECT_DIR=$(dirname "$TAW_DIR")
PROJECT_NAME=$(basename "$PROJECT_DIR")
WORKTREE_DIR="$AGENT_DIR/worktree"

# Check if git mode
IS_GIT_MODE=false
if [ -f "$TAW_DIR/.is-git-repo" ]; then
    IS_GIT_MODE=true
fi

# ============================================================================
# Functions
# ============================================================================

# Create attach symlink and prompt to continue
create_attach_and_prompt() {
    # Find TAW_HOME
    if [ -L "$TAW_DIR/new-task" ]; then
        NEW_TASK_TARGET="$(readlink "$TAW_DIR/new-task")"
        TAW_HOME="$(cd "$(dirname "$NEW_TASK_TARGET")/../.." && pwd)"
        ln -sf "$TAW_HOME/_taw/bin/attach" "$AGENT_DIR/attach" 2>/dev/null || true
    fi

    echo ""
    echo "  Task recovered! You can now:"
    echo "    - Press Enter to start working on this task"
    echo "    - Press 'q' to close this window"
    echo ""
    read -p "  Your choice: " -n 1 continue_choice
    echo ""

    if [ "$continue_choice" = "q" ] || [ "$continue_choice" = "Q" ]; then
        exit 0
    fi

    # Run attach script to start claude
    if [ -x "$AGENT_DIR/attach" ]; then
        exec "$AGENT_DIR/attach"
    else
        echo "  ${EMOJI_WARNING} Attach script not found. Please manually run:"
        echo "    $AGENT_DIR/attach"
        exit 0
    fi
}

# Recovery function
perform_recovery() {
    case "$CORRUPTED_STATUS" in
        missing_worktree)
            # Branch exists, recreate worktree
            echo "  Creating worktree from branch '$TASK_NAME'..."
            git -C "$PROJECT_DIR" worktree prune 2>/dev/null || true
            if git -C "$PROJECT_DIR" worktree add "$WORKTREE_DIR" "$TASK_NAME" 2>/dev/null; then
                echo "  ${EMOJI_DONE} Worktree recreated successfully!"
                create_attach_and_prompt
            else
                echo "  ${EMOJI_WARNING} Failed to recreate worktree."
                exit 1
            fi
            ;;
        not_in_git)
            # Worktree exists but not registered, try to repair
            echo "  Re-registering worktree..."
            git -C "$PROJECT_DIR" worktree prune 2>/dev/null || true
            # Remove and recreate
            if [ -d "$WORKTREE_DIR" ]; then
                rm -rf "$WORKTREE_DIR"
            fi
            if git -C "$PROJECT_DIR" worktree add "$WORKTREE_DIR" "$TASK_NAME" 2>/dev/null; then
                echo "  ${EMOJI_DONE} Worktree re-registered successfully!"
                create_attach_and_prompt
            else
                echo "  ${EMOJI_WARNING} Failed to re-register worktree."
                exit 1
            fi
            ;;
        invalid_git)
            # .git file corrupted, recreate worktree
            echo "  Recreating worktree (existing directory will be removed)..."
            git -C "$PROJECT_DIR" worktree prune 2>/dev/null || true
            if [ -d "$WORKTREE_DIR" ]; then
                # Try to save any uncommitted changes
                local backup_dir="$AGENT_DIR/.worktree-backup"
                echo "  Backing up worktree contents..."
                mv "$WORKTREE_DIR" "$backup_dir" 2>/dev/null || true
            fi
            if git -C "$PROJECT_DIR" worktree add "$WORKTREE_DIR" "$TASK_NAME" 2>/dev/null; then
                echo "  ${EMOJI_DONE} Worktree recreated!"
                # Try to restore backed up files (excluding .git)
                if [ -d "$AGENT_DIR/.worktree-backup" ]; then
                    echo "  Restoring backed up files..."
                    rsync -a --exclude='.git' "$AGENT_DIR/.worktree-backup/" "$WORKTREE_DIR/" 2>/dev/null || true
                    rm -rf "$AGENT_DIR/.worktree-backup"
                fi
                create_attach_and_prompt
            else
                echo "  ${EMOJI_WARNING} Failed to recreate worktree."
                exit 1
            fi
            ;;
        missing_branch)
            # Worktree exists but branch is gone, create branch from HEAD
            echo "  Creating branch from worktree state..."
            if [ -d "$WORKTREE_DIR" ]; then
                # Get current HEAD from worktree (if possible)
                local head_commit=""
                if [ -f "$WORKTREE_DIR/.git" ]; then
                    head_commit=$(git -C "$WORKTREE_DIR" rev-parse HEAD 2>/dev/null) || true
                fi
                if [ -n "$head_commit" ]; then
                    git -C "$PROJECT_DIR" branch "$TASK_NAME" "$head_commit" 2>/dev/null || true
                    echo "  ${EMOJI_DONE} Branch '$TASK_NAME' created from worktree HEAD!"
                    create_attach_and_prompt
                else
                    echo "  ${EMOJI_WARNING} Cannot determine worktree HEAD. Creating from main branch..."
                    local main_branch
                    main_branch=$(get_main_branch "$PROJECT_DIR")
                    git -C "$PROJECT_DIR" branch "$TASK_NAME" "$main_branch" 2>/dev/null || true
                    create_attach_and_prompt
                fi
            else
                echo "  ${EMOJI_WARNING} Worktree directory not found."
                exit 1
            fi
            ;;
    esac
}

# Cleanup function
perform_cleanup() {
    echo "  Removing task '$TASK_NAME'..."

    # Remove worktree
    if [ -d "$WORKTREE_DIR" ]; then
        echo "  Removing worktree..."
        git -C "$PROJECT_DIR" worktree remove "$WORKTREE_DIR" --force 2>/dev/null || rm -rf "$WORKTREE_DIR"
    fi
    git -C "$PROJECT_DIR" worktree prune 2>/dev/null || true

    # Delete branch
    if git -C "$PROJECT_DIR" rev-parse --verify "$TASK_NAME" &>/dev/null; then
        echo "  Deleting branch..."
        git -C "$PROJECT_DIR" branch -D "$TASK_NAME" 2>/dev/null || true
    fi

    # Remove agent directory
    echo "  Removing task directory..."
    rm -rf "$AGENT_DIR"

    echo "  ${EMOJI_DONE} Task cleaned up successfully!"
    echo ""
    echo "  Press any key to close this window..."
    read -n 1
}

# ============================================================================
# Main UI
# ============================================================================

# Display current status
clear
echo "╭─────────────────────────────────────────────────────────────────╮"
echo "│  ${EMOJI_WARNING} Corrupted Task Detected                                     │"
echo "╰─────────────────────────────────────────────────────────────────╯"
echo ""
echo "  Task: $TASK_NAME"
echo "  Status: $(get_worktree_status_description "$CORRUPTED_STATUS")"
echo ""

# Show task description if exists
if [ -f "$AGENT_DIR/task" ]; then
    echo "  ─────────────────────────────────────────────────────────────────"
    echo "  Task Description:"
    head -5 "$AGENT_DIR/task" | sed 's/^/    /'
    echo "  ─────────────────────────────────────────────────────────────────"
    echo ""
fi

# Show recovery options based on status
echo "  Options:"
echo ""

case "$CORRUPTED_STATUS" in
    missing_worktree)
        echo "    [1] Recover - Recreate worktree from branch"
        echo "    [2] Cleanup - Delete task and branch"
        ;;
    not_in_git)
        echo "    [1] Recover - Re-register worktree with git"
        echo "    [2] Cleanup - Delete worktree directory and task"
        ;;
    invalid_git)
        echo "    [1] Recover - Recreate worktree (may lose local changes)"
        echo "    [2] Cleanup - Delete corrupted worktree and task"
        ;;
    missing_branch)
        echo "    [1] Recover - Create branch from worktree state"
        echo "    [2] Cleanup - Delete worktree and task"
        ;;
esac

echo "    [3] Cancel - Do nothing (window will close)"
echo ""

# Get user choice
read -p "  Select option [1-3]: " -n 1 choice
echo ""
echo ""

case "$choice" in
    1)
        echo "  Recovering task..."
        perform_recovery
        ;;
    2)
        echo "  Cleaning up task..."
        perform_cleanup
        ;;
    3|*)
        echo "  Cancelled."
        exit 0
        ;;
esac
